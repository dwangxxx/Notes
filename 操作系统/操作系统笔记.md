## 孤儿进程和僵尸进程
- 孤儿进程是说一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进行将被init进程所收养，并且由init进程对它们完成状态收集工作。因为孤儿进行会被init进程收养，所以孤儿进程不会对系统造成伤害。
- 僵尸进程就是一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或waitpid()获取了子进程信息后才会释放。如果子进程释放，而父进程并没有调用wait()或者waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
系统能使用的进程号是有限的，如果产生大量僵尸进程，可能会因为没有可用的进程号而导致系统不能产生新的进程。如果要消灭系统中大量的僵尸进程，只需要将父进程杀死，此时僵尸进程就会变成孤儿进程，从而被init进程收养。
## 怎样来清除僵尸进程
- 改写父进程，在子进程死后要为它收尸。具体做法是接管SIGCHLD信号。子进程死后， 会发送SIGCHLD信号给父进程，父进程收到此信号后，执行 waitpid()函数为子进程收尸。这是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，尽管对的默认处理是忽略， 如果想响应这个消息，可以设置一个处理函数。
- 把父进程杀掉。父进程死后，僵尸进程成为"孤儿进程"，过继给1号进程init，init始终会负责清理僵尸进程，关机或重启后所有僵尸进程都会消失。

## 进程与线程区别
- 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源。

- 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

- 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 静态链接和动态链接的区别
- 静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内，并制作成目标文件以及可以独立运作的可执行文件。静态库一般是一些外部函数与变量的集合。静态库很方便，但是如果我们只是想用库中的某一个函数，仍然需要把所有内容都链接进去。一个更现代的方法是使用共享库，避免了在文件中静态库的大量重复。
- 动态链接可以在首次载入时执行，也可以在程序开始执行的时候完成。这是由动态链接器完成，比如标准c库通常就是动态链接的，这样所有的程序可以共享一个库，而不用分别进行封装。

## 编译过程
- 预处理阶段：处理以#开头的预处理命令
- 编译阶段：编译成汇编文件
- 汇编阶段：将汇编文件翻译成可重定位的目标文件，此文件中有符号表等数据
- 链接阶段：将可重定位目标文件和printf.o等单独编译好的目标文件进行合并，得到最终的可执行目标文件

## 进程状态
进程有五种状态：创建，就绪，运行，等待和终止

## 进程调度算法
- 先来先服务：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行。另外也不利于IO密集型进程，因为这种进程每次进行IO操作之后又得重新排队。
- 短作业优先：非抢占式的调度算法
- 最短剩余时间
- 时间片算法
- 优先级算法

## 系统调用和库函数区别
- 系统调用时应用程序向系统内核请求服务的方式。可以包括硬件相关的服务，或者进程创建、调度等。系统调用时程序和操作系统之间的重要接口。会发生进程地址空间的切换。
- 库函数就是把一些常用的函数编写到一个文件中，应用程序调用，发生在用户地址空间。
- 调用开销方面，系统调用需要在用户空间和内核环境间切换，开销较大；而库函数调用开销较小。

## 进程死锁
在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。死锁产生条件：互斥、占有和等待、不可抢占、环路等待。

## 进程同步的方式
- 临界区：临界区是一段代码，在临界区内进程将访问临界资源。任何时候最多只有一个进程可以进入临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
- 互斥量：使用一个互斥的变量来直接制约多个进程，每个进程只有拥有这个变量才具有访问公共资源的权限。
- 信号量：是一个整型变量，可以对其执行自增和自减操作，自减操作通常也叫做P操作，自增操作也称为V操作。这两个操作被设置成原语操作，是不可分割的。
- 管程：管程使用的是面向对象思想，将表示共享资源的数据结构还有相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。

## 进程通信的方式
- 管道
(1) 管道是半双工的，数据只能向一个方向流动；如果需要双方通信，需要建立起两个管道。
(2) 管道只能用于父子进程或者兄弟进程之间或者说具有亲缘关系的进程。
(3) 管道对于管道两端的进程而言，就是一个文件，但不是普通文件，不属于某种文件系统，只存在于内存中。
(4) 管道的实质是一个内核缓冲区，，进程已先进先出的方式从缓冲区存取数据，管道一端的进程顺序将数据写入缓冲区，另一端的进程则顺序的读出数据。
- 命名管道
这种管道也叫FIFO。命名管道不同于管道的地方，在于它提供了一个路径名与之关联，以命名管道的文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，只要可以访问文件系统中的这个路径，就能够彼此通过命名管道相互通信。命名管道严格遵守先进先出原则。命名管道的名字存在于文件系统中，但是内容存放在内存中。
- 消息队列
消息队列是消息的链表，具有特定的格式，是存放在内存中的，并且每个消息队列具有唯一的标识符。消息队列只允许一个或多个进行向他写入或者读取消息。利用消息队列，一个进程可以将一个数据块发送到另一个进程，每个数据块都有一个类型，接受进程可以独立地接受含有不同类型的数据结构，这个过程是异步的，我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列的数据块有一个最大长度的大小限制。
**消息队列使用有三个应用场景：解耦，异步和削峰**
- 共享内存
(1) 共享内存是针对其他通信机制运行效率较低而设计的，它可以让多个进程可以直接读写一块内存空间，是最快的IPC形式；
(2) 为了在多个进程间交换信息，**内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间**。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率
(3) 由于多个进程共享一段内存，因此需要依靠某种同步机制来达到进程间的同步和互斥。

- socket
(1) socket就是套接字，套接字也是一种通信机制，凭借这种机制，可以让不在同一台主机上的两个进程，通过网络进行通信，一般可以用在客户端和服务器之间的通信；
(2) 实际上，socket是在应用层和传输层之间的一个抽象层，它吧TCP/IP协议的传输层里面的复杂的操作，抽象为几个简单的接口，供应用层调用，实现进程在网络间的通信。

## TCP三次握手
(1) 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待；
(2) 客户端socket对象调用connect()向服务器发送一个SYN请求TCP连接并阻塞；
(3) 服务器完成第一次握手，发送SYN和ACK应答给客户端；
(4) 客户端收到服务器端发送的应答后，从connect()返回，在发送一个ACK给服务器；
(5) 服务器socket对象接收到客户端第三次握手ACK确认，此时服务端从accept()返回，建立连接。

## 虚拟内存
虚拟内存是操作系统对物理内存的一种抽象，它让系统看上去具有比实际物理内存大得多的内存内存空间，使得系统可以运行多个进程。将物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或资源的某些页面首先加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程。
**虚拟内存技术是通过分页实现的，将虚拟内存和物理内存分页，分别为页和页框**。

## 页面替换算法
- 最佳算法，所选择的被换出的页面将是最长时间内不再访问的页面，只是一种理论上的算法。
- 先进先出，选择换出的页面是最先进入的页面
- LRU，LRU将最近最久未使用的页面换出。为了实现LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未被访问的。因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高。
- 时钟算法

## Linux文件系统
软链接：其实就是创建一个文件，文件存储的是源文件的路径，当访问软链接的时候，通过存储的路径进行访问源文件。删除源文件后，软链接指向的文件失效。
硬链接：在目录项中添加一个inode和文件名的对应项，直接指向相应的inode，创建硬链接时会增加引用计数，只有引用计数为0的时候才可以删除文件。

## 容器虚拟化
容器是一种虚拟化的方案，和传统的虚拟机(通过中间层”guerst OS”运行服务)不同，Docker直接运行在操作系统之上。因此容器虚拟化也被称之为操作系统虚拟化。Docker容器依赖于Linux内核特性，Namespace和Cgroups，所以只能运行在Linux之上。
一句话来概括的话，主机级虚拟化就是通过各种各样的手段，把物理资源重新分配，然后抽象出一部分拿来做虚拟机的虚拟硬件，是对硬件的模拟；而容器虚拟化技术相当于把操作系统进行虚拟化，把物理的操作系统模拟为逻辑上的多个操作系统，不同的操作系统有自己的用户空间，实现了应用程序间的隔离。虚拟机需要虚拟机管理系统模拟一个虚拟的硬件系统。
- 主机虚拟化：在VMM(又叫做hypervisor)之上，可以模拟出逻辑的计算机虚拟环境，然后安装操作系统，使其成为一台逻辑上虚拟的计算机主机，该主机有自己的系统内核，有自己的用户空间，可以在自己的用户空间内跑各种各样的应用程序。对于主机级虚拟化，我们的实现方式一般是想办法去模拟出硬件环境，模拟出虚拟的cpu、内存、硬盘、网卡等资源，然后在这些虚拟资源之上安装合适的操作系统来控制这些资源。

## mmap过程
- 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域
- 调用内核空间的系统调用函数mmap(不同于用户空间函数)，实现文件物理地址和进程虚拟地址的一一映射关系
- 进程发起对这片映射空间的访问，引发缺页中断，实现文件内容到物理内存的拷贝（前两个阶段仅是创建了虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝至主存，真正的文件读取是当进程发起读或者发起写操作时完成）

## 文件系统
Unix文件查找/a/b/c：超级数据块中得到根目录文件地址，根目录文件中得到a的i节点地址，a的i节点中得到a目录文件地址，a目录文件中得到b的i节点地址，b的i节点中得到b目录文件地址，b目录文件中得到c的i节点地址，c的i节点中得到文件物理地址。

## bind()函数
bind()函数接收一个可调用对象，返回一个新的可调用对象，为函数绑定参数
```C++
auto check6 = bind(check_size, _1, 6);
```

- strcpy主要实现字符串变量间的拷贝
- sprintf主要实现其他数据类型格式到字符串的转化
- memcpy主要是内存块间的拷贝

将引用作为函数参数特点，在内存中并没有产生实参的副本，它是直接对实参操作；而是用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元。使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，因为指针是一个变量，需要占有存储单元。

## IO控制方式
(1) 直接IO(轮询方式)
该方式采用用户程序直接控制主机与外部设备之间输入/输出操作。CPU必须不停地循环测试IO设备的状态端口，当发现设备处于准备好状态时，CPU就可以与IO设备进行数据存取操作。这种方式下的CPU与IO设备是串行工作的，输入/输出一般以字节或者字为单位进行。这种方式频繁地测试IO设备，IO设备的速度相对来说又很慢，极大地降低了CPU的处理效率，并且仅仅依靠测试设备状态位来进行数据传送，不能及时发现传输中的硬件错误。
(2) 中断
当IO设备结束时，就会向CPU发出中断请求信号，CPU收到信号就可以采取相应措施。当某个进程要启动某个设备时，CPU就向相应的设备控制器发出一条设备IO启动指令，然后CPU又返回做原来的工作。CPU与IO设备可以并行工作，与程序查询 相比，大大提高了CPU的利用率。但是在中断方式下，同程序查询方式一样，也是以字节或者字为单位进行。但是该方法大大降低了CPU的效率，因为当中断发生的非常频繁时，系统需要进行频繁的中断源识别、保护现场、中断处理、恢复现场。这种方法对于以“快”为存取单位的块设备，效率是低下的。
(3) DMA
DMA方式也称为直接主存存取方式。

## 大端小端模式
- 大端：低地址存高位数据，高地址存低位数据，此方法的优点是符号位的判定固定位第一字节，容易判断正负。
- 小端：低地址存低位数据，高地址存高位数据，此方法的有点是，强制转换数据时不需要调整字节内容，1、2、4字节的存储方式一样。

## malloc内存分配过程

使用malloc接口分配一段连续的内存空间，不使用时使用free可以释放这段内存空间。

Linux进程的地址空间主要分为：
- 正文：这是整个用户空间的最低地址部分，存放的是指令
- 初始化数据段：这里存放的是初始化的全局变量
- 未初始化正文段：存放的是未初始化的全局变量
- heap：堆，供程序动态调用的区域，堆自低地址向高地址增长。
- stack：栈区域，自高地址向低地址增长。

malloc分配空间时是在heap上分配的，实际上，linux维护 一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break网上，是未映射的地址空间，如果访问这段空间则程序会报错。

如果需要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用来操作break指针。两个系统调用的原型如下：
```C++
int brk(void *addr);
void *sbrk(intptr_t increment);
```
brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指的位置。brk在执行成功时返回0，否则返回-1，并设置errno为ENOMEM；sbrk成功时返回break移动之后所指的地址，否则返回(void*)-1。

需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的。

通过malloc申请后的空间，并没有初始化，所以在使用前记得初始化，不小心当做右值使用，出错的概率很大。因为使用malloc程序分配空间只是分配了虚拟地址空间，但是并没有与实际的物理内存进行映射，所以需要实际写的时候才会与实际的物理内存进行映射。

如果一个进程频繁的申请、释放一个页面，必然会导致大量的系统调用，从而降低进程的效率。如果内存管理在进程进程释放一块内存时不是返回给系统而是将其cache住，留待下次使用，这样就可以减少系统调用的次数，从而提高进程的效率。它的代价是释放的内存不立刻返还给系统，以内存空间换取进程的效率。Libc就是采用这种策略，只有堆顶有连续128k(可通过mallopt配置)空闲内存时才会调用brk通知内核释放这段内存。这就导致下述的内存空洞。

当堆顶连续空闲内存数量大于该阀值时, libc的内存管理将调用系统调用brk来调整堆顶地址，释放空间。该值缺省为128k。

malloc系统调用，当申请内存小于128k时，调用brk函数调整break指针，当申请内存大于128k时，调用mmap函数映射一个内存区域。