## 什么是内存对齐
首先用一个例子来解释这个问题，如下的程序中，在理论上，32位的系统下，int占4byte，char占1byte，那么将它们放到一个结构体中应该占5byte，但是实际上是8byte，这就是内存对齐所导致的。
```C++
#include<stdio.h>
struct{
    int x;
    char y;
}s;

int main()
{
    printf("%d\n", sizeof(s));
    return 0;
}
```
现代计算机中内存空间都是按照byte划分的，从理论上将讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常为4或8）的倍数，这就是所谓的内存对齐。
## 为什么要进行内存对齐
尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，4字节，8字节等为单位来存取内存，这叫做内存存取粒度。
首先考虑4字节存取粒度的处理器取int类型变量，该处理器只能从地址为4的倍数的内存开始读取数据。
假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理区去取数据时，要从0地址开始读取第一个4字节块，剔除不想要的字节，然后从地址4开始读取下一个4字节块，同样剔除不需要的数据，最后留下的两块数据合并放入寄存器，这需要做很多工作。
如果对数据进行了内存对齐，int类型数据只能存放在按照对其规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。
## 内存对齐规则
每个特定平台上的编译器都有自己的默认“对齐系数”，gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1, 2, 4, 8, 16来改变这一系数。
有效对齐值：是给定值和结构体中最长数据类型长度中较小的那个，有效对齐值也叫对齐单位。
对齐规则：
（1）结构体第一个成员的偏移量(offset)为0，以后每个成员相对于结构体首地址的offset都是该成员与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
（2）结构体总大小为有效对齐值的整数倍，如有需要编译器会在最后一个成员之后加上填充字节。
```C++
//32位系统
#include<stdio.h>
struct
{
    int i;    
    char c1;  
    char c2;  
}x1;

struct{
    char c1;  
    int i;    
    char c2;  
}x2;

struct{
    char c1;  
    char c2; 
    int i;    
}x3;

int main()
{
    printf("%d\n",sizeof(x1));  // 输出8
    printf("%d\n",sizeof(x2));  // 输出12
    printf("%d\n",sizeof(x3));  // 输出8
    return 0;
}
```
