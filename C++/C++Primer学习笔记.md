## const

编译器对const常量的处理：
- 当碰见常量声明时在符号表中放入常量
- 编译过程中若发现使用常量则直接以符号表中的值替换
- 编译过程中若发现const使用了extern或者&操作符，则给对应的常量分配存储空间

## decltype类型指示符

如果希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，引入了类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，但是不实际计算表达式的值：
```C++
decltype(f()) sum = x;  // sum的类型就是函数f的返回类型
```
decltype处理顶层const和引用的方式与auto有所不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：
```C++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;     // x类型是const int
decltype(cj) y = x;     // y的类型是const int&, y绑定到变量x
decltype(cj) z;     // 错误：z是一个引用，必须初始化
```
需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外。
- decltype和引用
```C++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;  // 正确: 加法的结果是int，因此b是一个(未初始化的)int
decltype(*p) c;     // 错误: c是int&，必须初始化
```
如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&，而非int。
decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用得表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。
## 尾置返回类型
在C++11新标准中还有一种可以简化函数声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：
```C++
// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int (*) [10];
```
因为我们吧函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。
## 返回指向函数的指针
```C++
using F = int(int*, int);
using PF = int(*) (int*, int);
// 定义返回函数的指针
PF f1(int);
F *f1(int);
// 显式定义返回函数的指针
int (*f1(int)) (int*, int);
```
按照由内向外的顺序阅读这条声明语句：可以看到f1有形参列表，所以f1是个函数；f1前面有*，所有f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。还可以使用尾置返回类型：
```C++
auto f1(int) -> int (*) (int*, int)
```
## this指针
this指针是一个常量指针，不允许改变this中保存的地址。默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在类Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但是它仍需要遵循初始化规则，意味着(在默认情况下)我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。
如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。
但是this是隐式的，C++的做法是允许吧const关键字放在成员函数的参数列表之后。此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数。
因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。注：非常量对象可以调用常量和非常量成员函数，但是常量对象只能调用常量成员函数。

## static关键字
static成员函数只能访问static变量，不能访问非static变量，因为static成员函数没有this指针。

## 泛型算法
- fill，接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列的每个元素。
```C++
fill(vec.begin(), vec.end(), 0)
```
向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。
- 拷贝算法
拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将 输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含于输入序列一样的元素。
```C++
int a1 = {1, 2, 3, 4, 5};
int a2[sizeof(a1) / sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
```

## 第十二章：动态内存
静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在。
- 动态内存和智能指针
在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。（如果忘记释放内存，就会产生内存泄漏的情况）。
新标准库提供了两种智能指针类型来动态管理对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象。
- shared_ptr类
shared_ptr可以协调对象的析构，但是这仅限于其自身的拷贝(也就是shared_ptr)之间。因此更推荐使用make_shared而不是new，这样就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。考虑下面对shared_ptr进行操作的函数：
```C++
// 在函数被调用时ptr被创建并初始化
void process(shared_ptr<int> ptr)
{
    // 使用ptr
} // ptr离开作用域，被销毁
```
如下的做法是会导致错误的：
```C++
int *x(new int(1024));
process(x);     // 错误，不能将int*转换成一个shared_ptr<int>
process(shared_ptr<int>(x));    // 合法，但是内存会被释放
int j = *x;     // 未定义的，x是一个悬空指针
```
- unique_ptr
```C++
// unique_ptr操作
u.release();    // u放弃对指针的控制权，返回指针，并将u置为空
u.reset();      // 释放u指向的对象
u.reset(q);     // 如果提供了内置指针q，令u指向这个对象
u.reset(nullptr);
```
当我们把函数名作为一个值使用时，该函数自动转换成函数指针。
- weak_ptr
weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使weak_ptr指向对象，对象还是会被释放。
```C++
weak_ptr<T> w;
weak_ptr<T> w(sp);  // 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型
w = p;  // p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象
w.reset();  // 将w置为空
w.use_count();   // 与w共享对象的shared_ptr的数量
w.expired();    // 若w.use_count()为0，返回true，否则返回false
w.lock();       // 如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr
```
## 虚函数
回避虚函数的机制：
在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。可以使用作用域运算符实现这一目的。通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数的默认机制。如果此时没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。因为在调用类的成员函数时，传入了一个this指针，该指针指向派生类本身，则虚函数被解析为派生类的虚函数，这就会导致无限的递归调用。

## mmap内存映射原理
mmap内存映射的实现过程，总的来说可以分为三个阶段：
（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

- 进程在用户空间调用库函数mmap

- 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

- 为此虚拟地址分配一个vm_area_struct，接着对这个结构的各个域进行初始化

- 将新建的vm_area_struct插入进程的虚拟地址区域链表或树中

（二）调用内核空间的系统调用函数mmap(不同于用户空间函数)，**实现文件物理地址和进程虚拟地址的一一映射关系（重点）**

- 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体，每个文件结构体维护着和这个已打开文件相关各项信息。

- 通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap

- 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址

- 通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系(将磁盘地址保存在页表中)。此时，这片虚拟地址并没有任何数据关联到主存中

（三）进程发起对这片映射空间的访问，引发缺页中断，实现文件内容到物理内存的拷贝。

注：前两个阶段仅在创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝到主存。真正的文件读取是当进程发起读或者操作时。

- 进程的读写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

- 缺页异常进行一系列判断，确认无非法操作后，内核发起请求调页过程。

- 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

- 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

- **缺页中断时操作系统怎么知道磁盘地址**
- 缺失页的磁盘地址保存在页表项中。

- 页表项，如果页是否存在位为1，则其地址段就是用来保存物理页框号和脏位、修改位等信息。

- 当页是否存在位为0时，表达当前页不在内存中，除了“页存在位”以外的其他位都用来保存页所在的磁盘地址。
