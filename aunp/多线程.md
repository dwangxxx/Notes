# 多线程环境

## 可重入函数

如果一个函数能被多个线程同时调用且不发生竞态条件，称此函数是线程安全的，或者说其是可重入函数。Linux库函数只有一小部分是不可重入的，比如inet_ntoa函数，以及getservbyname和getservbyport函数等。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。不过Linux对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上_r。在多线程程序中调用库函数，一定要使用可重入版本，否则可能导致预想不到的结果。

## 线程与进程

如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否自动创建和父进程相同数量的线程呢？答案是否。子进程只拥有一个执行线程，就是调用fork的那个线程的完美复制。并且子进程将自动继承父进程中互斥锁的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。这就引起了一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态，即是加锁状态还是解锁状态。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁。

pthread提供了一个专门的函数pthread_atfork，以确保fork调用之后父子进程都拥有一个清楚的锁状态：
```C++
#include <pthread.h>
int pthread_atfork(void (prepare*)(void), void (*parent) (void), void (*child) (void));
```
- prepare将会在fork调用创建出子进程之前被执行，用来锁住所有父进程中的互斥锁。
- parent在fork调用创建出子进程之后，而fork返回之前，在父进程中被执行，作用是释放所有在prepare句柄中被锁住的互斥锁。
- child句柄是在fork返回之前，在子进程中被执行，也是用于释放所有在prepare中被锁住的互斥锁。