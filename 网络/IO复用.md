## IO复用模型
- select(时间复杂度O(n))

仅仅知道有IO时间发生，但是并不知道是哪几个流(可能是一个，多个，甚至是全部)，所以只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
select是通过设置或者检查存放fd标志位的数据结构来进行下一步处理，这样所带来的的缺点是：
(1)单个进行可监视的fd数量被限制，即能监听端口的大小有限。
(2)对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：
当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
并且每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。
(3)需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。
- poll(时间复杂度O(n))

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是他没有设置最大连接数的限制，原因是它是基于**链表**来存储的。

- epoll(时间复杂度O(1))

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的IO事件通知我们，所以说epoll实际上是事件驱动的(每个事件关联上fd)，此时我们对这些流的操作都是有意义的。(复杂度降低到了O(1))。

select, poll, epoll都是IO多路复用的机制，IO多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的读写操作。但是**select, poll和epoll本质上都是同步IO，因为他们都需要在读写事件就绪后自己负责读写，也就是说整个读写过程是阻塞的**，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。
epoll有EPOLL LT和EPOLL ET两种触发模式，LT是默认的模式(水平触发)，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

## epoll为什么要有EPOLL ET触发模式？

如果采用EPOLL_LT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。
而采用EPOLL_ET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。

