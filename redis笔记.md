## redis介绍
redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件。
redis是一种高级的key:value存储系统，其中value支持五种数据类型：
- 字符串(strings)
- 字符串列表(lists)
- 字符串集合(sets)
- 有序字符串集合(sorted sets)
- 哈希(hashes)

关于key：
- key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率
- key也不要太短，太短会造成key可读性降低
- 在一个项目中，key最好使用同一的命名模式

## redis数据结构
- strings
如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么redis就和memcache非常像。说明strings类型是一个很基础的数据类型。例子：
```redis
set mystr "hello"
get mystr
```
还可以对字符串类型进行数值操作：
```redis
set mynum "2"
incr mynum -> (integer) 3
get mynum -> "3"
```
在遇到数值操作时，redis会将字符串类型转换成数值。由于INCR等指令本身就具有原子操作的特性，所以完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。假如某场景下有3个客户端同时读取了mynum的值，然后同时对其进行了加1操作，那么最后的mynum值一定是正确的。
- lists
redis的lists底层实现并不是数组，而是链表，也就是说对一个具有上百万元素的lists来说，在头部和在尾部插入一个新元素，其时间复杂度是常数级别的。但是其元素定位速度比较慢。例子：
```redis
lpush mylist "1"  // 在列表头部插入元素"1"
rpush mylist "2"  // 在列表右侧插入元素"2"
lpush mylist "0"  // 在列表左侧插入元素"0"
lrange mylist 0 1  // 列出列表中从编号0到编号1的元素
```
lists应用广泛：
1. 可以利用lists来实现一个消息队列，而且可以确保先后顺序。
2. 利用lrange可以很方便实现分页功能。
3. 在博客系统中，每篇博文的评论也可以存入一个单独的list中。

- 集合
redis的集合是一种无序的集合，集合中的元素没有先后顺序。集合操作：添加新元素、删除已有元素、取交集、取并集、取差集等。例子：
```redis
sadd myset "one"
sadd myset "two"
smembers myset  // 列出集合myset中的所有元素
sismember myset "one"  // 判断元素是否存在集合中
sadd yourset "1"
sadd yourset "2"
sunion myset yourset  // 对两个集合求并集
```
对于集合的使用，也有一些常见的方式，比如qq有一个社交功能叫好友标签，可以将每一个用户的标签都存储在一个集合中。

- 有序集合
redis不但提供了无序集合，还提供了有序集合。有序集合中的每个元素都关联一个序号，这就是排序的依据。很多时候，将redis中的有序集合叫做zsets。因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等。例子：
```redis
zadd myset 1 baidu.com  // 向集合中添加一个元素，并且赋予序号1
zadd myset 3 xxx
zadd myset 2 abcd
zrange myset 0 -1 with scores  // 列出集合所有元素，同时列出其序号
```
- hashes(哈希)
hashes存储的是字符串和字符串之间的映射，比如一个用户要存储其全名、姓氏等等，就适合使用哈希。例子：
```redis
// 建立hash，并且赋值
hmset user:001 username dengwang password 123456 age 23
hgetall user:001    // 列出hash内容
hset user:001 age 30    // 更改hash中的某一个值
```

## redis持久化
redis提供了两种持久化方式，分别是RDB(redis DataBase)和AOF(Append Only File)。RDB就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；AOF就是换了一个角度来实现持久化，就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后重复执行一遍，就可以实现数据恢复了。
RDB和AOF两种方式可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，因为AOF方式的数据恢复完整度更高。如果没有数据持久化的需求，可以完全关闭RDB和AOF方式，这样的话，redis就变成一个纯内存数据库，就像memcache一样。
- redis持久化-RDB
RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。因此我们可以随时进行备份，因为快照文件总是完整可用的。**(即在产生快照的过程中，将当前快照写入到一个临时文件，持久化完成后再将这个临时文件替换上一次的持久化文件)**。
对于RDB方式，redis会单独fork一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。如果需要进行大规模数据的恢复，而对于数据恢复的完整度不是非常敏感，那RDB方式要比AOF方式更加高效。虽然RDB有不少优点，但是它的缺点也是不容忽视的。**如果对数据的完整性非常敏感，那么RDB方式就不适合，因为即使每五分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。**
- redis持久化-AOF
AOF方式是将执行过程中的写指令记录下来，在数据恢复时按照从前往后的顺序再将指令执行一遍。可以通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作(set)，redis就会被追加到AOF文件的末尾。
默认的AOF持久化策略是每秒钟fsync一次(fsync是指把缓存中的写指令记录到磁盘中)，因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1s的数据。
如果在追加日志时，恰好遇到磁盘空间满、inode满或者断电等情况导致日志写入不完整时，也没有关系，**redis提供了redis-check-aof工具，可以用来进行日志修复**。
因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写(rewrite)机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件压缩，只保留可以恢复数据的最小指令集。例如：加入我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，我们可以把这100条指令合并成1条set指令，这就是**重写机制**的原理。
在进行AOF重写时，redis启动一个新的进程来进行重写操作。
AOF方式的另一个好处，通过一个场景重现：在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清除了，在这种情况下，只要配置了AOF持久化方式，且AOF文件还没有被重写，那么我们就可以以最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了，因为如果此时AOF文件被重写了，重写过后的AOF文件中就只剩一条FLUSHALL语句，之前的状态无法恢复。
AOF缺陷：在同样的数据规模下，AOF文件要比RDB文件的体积大。而且AOF方式的恢复速度要比RDB方式慢。
如果出现了AOF文件被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来恢复出错的文件：
> 1、备份被写坏的AOF文件

> 2、运行redis-check-aof -fix来进行修复

> 3、用diff -u来查看两个文件的差异，确认问题点

> 4、重启redis，加载修复后的AOF文件

## redis持久化-AOF重写
AOF重写的内部运行原理：在重写即将开始之际，redis会创建一个重写子进程，这个子进程会首先读取现有的AOF文件，并将包含的指令进行分析压缩并写入到一个临时文件中。与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区，一边继续写入到原有的AOF文件中，这样是**保证了原有的AOF文件的可用性，避免在重写过程中出现意外**。

## redis主从结构
单机的redis，能够承载的QPS大概就在上万到几万不等，对于缓存来说，一般都是用来支撑高并发的。因此架构做成主从架构，**一主多从，主负责写，并且将数据复制到其他的slave节点，从节点负责读**。所有的读请求全部走从节点，这样可以很轻松实现水平扩容，支持读高并发。
redis的主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。
redis的主从同步是异步进行的，这意味着主从同步并不会影响主逻辑，也不会降低redis的处理性能。
主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。

## redis主从复制核心机制
- redis采用异步方式复制数据到slave节点，不过从redis2.8开始，slave node会周期性地确认自己每次复制的数据量；
- 一个master node是可以配置多个slave节点的；
- slave node也可以连接其他的slave node；
- slave node做复制的时候，不会屏蔽master node的正常工作；
- slave node在做复制的时候，也不会block对自己的查询操作，他会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；
- slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。
**如果采用了主从架构，那么建议必须开启master node的持久化**，不建议用slave node作为master node的数据热备，因为那样的话，如果关掉master node的持久化，可能在master宕机重启的时候数据是空的，然后可能经过复制，slave node的数据也丢了。

## redis主从复制核心原理
当启动一个slave node的时候，它会发送一个PSYNC命令给master node。
- 如果这是slave node初次连接到master node，那么会触发一次full resynchronization全量复制。此时master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端client新收到的所有写命令缓存到内存中。RDB文件生成完毕后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送到slave，slave也会同步这些数据。slave node如果跟master node有网络故障，断开了连接，会自动重连，连接之后master node仅会复制给slave部分缺少的数据。
> 1、主从复制的断电续传：如果主从复制过程中，网络连接断掉，那么可以接着上次复制的点，继续复制下去，而不是从头开始复制一份。master node会在内存中维护一个backlog，master和slave都会保存一个replica offset还有一个master run id，offset就是保存在backlog中的。如果master和slave网络连接断了，slave会让master从上次replica offset开始继续复制，如果没有找到对应的offset，那么会执行一次全量复制。注：如果根据host+ip定位master node，是不靠谱的，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run id区分。
> 2、无磁盘化复制：master直接在内存中创建RDB，然后发送给slave，不会在自己本地落磁盘。只需要在配置文件中开启repl-diskless-sync yes即可。
> 3、过期key处理：**slave不会过期key，只会等待master过期key**。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。

## redis完整复制流程

slave node启动时，会在自己本地保存master node的信息，包括master node的host和ip，但是复制流程还没开始。slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接。然后slave node发送ping命令给master node。如果master设置了requirepass，那么slave node必须发送masterauth的口令过去认证。master node第一次执行全量复制，将所有数据发送给slave node。而在后续，master node持续将写命令，异步复制给slave node。
- 全量复制

(1) master 执行 bgsave ，在本地生成一份 rdb 快照文件。
(2) master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)
(3) master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。
(4) 如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。
(5) slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。
如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。
- 增量复制

(1) 如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。
(2) master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。
(3) master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。
- heartbeat

master每次接受到命令之后，现在内部写入数据，然后异步发送给slave node(异步的意思是说说主节点自身处理完写命令后直接返回给客户端， 并不等待从节点复制完成)。
- 异步复制

master每次接收到命令后，现在内部写入数据，然后异步发送给slave node。

## redis哨兵模式

- 哨兵介绍
哨兵主要有以下功能：
> 集群监控：负责监控redis master和slave进程是否正常工作。

> 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为警报通知给管理员。

> 故障转移：如果master node挂掉了，会自动转移到slave node上。

> 配置中心：如果故障转移发生了，通知client客户端新的master地址。

哨兵用于实现redis集群的高可用性，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。
> 故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到分布式玄机的问题。

> 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。

- 哨兵的核心知识
> 哨兵至少需要三个实例，来保证自己的健壮性。

> 哨兵 + redis的主从结构，是不保证数据零丢失的，只能保证redis集群的高可用性。

> 对于哨兵 + redis主从这种复杂的部署结构，尽量在测试和生产环境中都进行充足的测试和演练。

哨兵集群必须部署2个以上节点，如果哨兵集群仅仅部署了两个哨兵实例，quorum = 1。配置quorum = 1，如果master宕机，s1和s2中只要有1个哨兵认为master宕机了，就可以进行切换，同时s1和s2会选举出一个哨兵来执行故障转移。但是同时这个时候，需要majority，也就是大多数哨兵都是运行的。
```C++
2个哨兵，majority = 2
3个哨兵，majority = 2
4个哨兵，majority = 2
5个哨兵，majority = 3
...
```
如果此时仅仅是master进程宕机了，哨兵s1正常运行，那么故障转移是正常的。但是如果整个master和s1运行的机器宕机了，那么哨兵只有一个，此时就没有majority来允许执行故障转移，虽然另一个机器还有一个slave，但是故障不会转移。
- redis哨兵主备切换的数据丢失问题

**1、两种情况的数据丢失**

- 异步复制导致的数据丢失：因为master->slave的复制时异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这部分数据就丢失了。
- 脑裂导致的数据丢失：当某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着。此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成master。这个时候，集群就会有两个master，也就是所谓的脑裂。此时虽然某个slave被切换成了master，但是可能client还没来得及切换新的master，还得继续向旧master写数据。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会被清空，重新从新的master复制数据。而新的master并没有后来client写入的数据。因此，这部分数据也就丢失了。

**2、数据丢失问题的解决方案**

进行如下配置：
```redis
min-slaves-to-write 1  // 至少有1个slave
min-slaves-max-lag 10  // 数据复制和同步的延迟不能超过10s
```
如果说一旦所有的slave，数据复制和同步的延迟都超过了10s，那么这个时候，master就不会再接收任何请求了。
- 减少脑裂的数据丢失：如果一个master出现脑裂，跟其他slave丢失了连接，那么上面的配置可以确保说，如果不能继续给指定数量的slave发送数据，并且slave超过10s没有给自己ok消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多丢失10s的数据。

- **sdown和odown转换机制**

sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机；odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机。
sdown达成条件很简单，如果一个少报哪个ping一个master，超过了is-master-down-after-milliseconds指定的毫秒数之后，就主观认为master宕机了；如果一个哨兵在指定时间内，收到quorun数量的其他哨兵也认为那个master是sdown的，那么就认为是odown了。

- **哨兵集群的发现机制**

哨兵互相之间的发现，是通过 redis 的 pub/sub 系统实现的，每个哨兵都会往 __sentinel__:hello 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。

每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 __sentinel__:hello channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。

每个哨兵也会去监听自己监控的每个 master+slaves 对应的 __sentinel__:hello channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。

每个哨兵还会跟其他哨兵交换对 master 的监控配置，互相进行监控配置的同步。

- **slave配置的自动纠正**

哨兵会负责自动纠正slave的一些配置，比如slave如果要称为潜在的master候选人，哨兵会确保slave复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上。

- **slave-master选举算法**

如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：

> 跟 master 断开连接的时长
> slave 优先级
> 复制 offset
> run id
如果一个 slave 跟 master 断开连接的时间已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。
```redis
(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state
```
接下来会对 slave 进行排序：
> 按照 slave 优先级进行排序，slave priority 越低，优先级就越高。
> 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。
> 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。

- **quorun和majority**

每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。

如果 quorum < majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。

但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。

- **configuration epoch**

哨兵会对一套 redis master+slaves 进行监控，有相应的监控的配置。

执行切换的那个哨兵，会从要切换到的新 master（salve->master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。

如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。

- **configuration传播**

哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 pub/sub 消息机制。

这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。

## SDS与C字符的区别

### 常数复杂度获取字符串长度

因为C字符并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。**和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。设置和更新SDS的长度的工作是由SDS的API在执行时自动完成的。**每个sds.h/sdshdr结构代表一个SDS值：
```C
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存的字符串的长度
    int len;

    // 记录buf数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];
};
```

### 杜绝缓冲区溢出
除了获取字符串长度的复杂度高之外，C字符串不记录本身长度带来的一个问题是缓冲区溢出。例如：<string.h>/strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：
```C
char *strcat(char *dest, char *src);
```
因为C字符串不记录本身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会发生缓冲区溢出。

### 减少修改字符串时带来的内存重分配次数

对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组(额外的一个字符空间用来保存空字符)。因为C字符串的长度和底层数组之间存在着这种关联性，因此每次增长或者缩短一个C字符串，程序总要对保存这个C字符串的数组进行一次内存重分配操作：
- 如果程序执行的是增长字符串的操作，比如拼接操作，那么在执行这个操作之前，程序需要先通过内存重分配操作来扩展底层数组的空间大小--如果忘了就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作，那么在操作之后，需要通过内存重分配算法来释放空间，如果忘了就会产生内存泄漏。

但是内存重分配涉及到复杂的算法，并且可能需要执行系统调用，所以是一个比较耗时的操作。为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。

通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

- 空间预分配
- 惰性空间释放

### 二进制安全
C字符串中的字符必须符合某种编码，并且除了字符的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符就被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频等这样的二进制数据。

### 兼容部分C字符串函数
虽然SDS的API都是二进制安全的，但是它们一样遵循C字符串以空字符结尾的习惯，这样就可以使得其可以重用C字符串的一些库函数。

## 链表

- 链表节点实现：
```C
// adlist.h/listNode
typedef struct listNode {
    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;
}listNode;
```

- 链表实现
```C
// adlist.h/list
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup) (void *ptr);
    // 节点值释放函数
    void (*free) (void *ptr);
    // 节点值对比函数
    int (*match) (void *ptr, void *key);
} list;
```

## 跳跃表

跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批处理节点。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。

## 整数集合
整数集合是redis中用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t，int32_t和int64_t的整数值，并且保证集合中不会出现重复元素。每个intset.h/intset结构表示一个整数集合：
```C++
typedef struct intset {
    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];
} intset;
```
- 升级

当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素加到整数集合里面。分为三步：

(1) 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。

(2) 将底层数组现有的所有元素都转换成与新元素相同的类型，然后将类型转换后的元素放置到正确的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。

(3) 将新元素添加到底层数组里面。

- 降级

整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 压缩列表

> 压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表项的底层实现。

> 当一个哈希键只包含少量键值对，并且每个键值对的键和值要么是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做哈希键的底层实现。

## redis对象

redis没有直接使用其数据结构来实现键值对系统，而是基于这些数据结构创建了一个对象系统，这个系统包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象，每种对象都用到了前面提到的至少一种数据结构。

redis一共有五种对象：
- 字符串对象: REDIS_STRING
- 列表对象: REDIS_LIST
- 哈希对象: REDIS_HASH
- 集合对象: REDIS_SET
- 有序集合对象: REDIS_ZSET

这五种对象可以由不同的底层数据结构实现：
- 字符串对象：字符串对象的编码可以是int、raw(SDS简单动态字符串结构)或者embstr(embstr编码的简单动态字符串)。
- 列表对象：列表对象的编码可以是**ziplist(压缩列表)或者linkedlist(链表)**。linkedlist编码的列表对象在底层的双端列表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在**哈希对象、集合对象和有序集合对象中都会出现，字符串对象是redis五种类型对象中唯一一种会被其他四种对象嵌套的对象。**
- 哈希对象：哈希对象的编码可以是**ziplist(压缩列表)或者hashtable(哈希表)**。ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。hashtable编码的哈希对象使用字典作为底层实现，**哈希对象中的每个键值对都使用一个字典键值来保存：字典中的每个键都是一个字符串对象，字典中的每个值都是一个字符串对象**。
- 集合对象：集合对象的编码可以是**intset或者hashtable**。intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。
- 有序集合对象：有序集合的编码可以使**ziplist或者skiplist**。ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素保存元素的分值，压缩列表内的集合元素按照分值大小从小到大进行排序。skiplist编码的有序集合对象同时使用字典和跳跃表作为底层实现。

## 数据库
### 服务器中的数据库

redis服务器中的所有数据库都保存在服务器redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库:
```C++
struct redisServer {
    // ...
    // 一个数组，保存着服务器所有数据库
    redisDb *db;
    
    // 服务器数据库数量
    int dbnum;
    //...
};
```
在初始化的时候，程序会根据服务器的dbnum属性来决定应该创建多少个数据库。

### 切换数据库

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：
```C++
typedef struct redisClient {
    // ...
    
    // 记录客户端当前正在使用的数据库
    redisDb *db;

    //
};
```
redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。通过改变redisClient.db的指向，就可以切换数据库。

### 数据库键空间

redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，将这个字典称为键空间：
```C++
typedef struct redisDb {
    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;

    // ...
};
```
键空间和用户所见的数据库是直接对应的：
> 键空间的键就是数据库的键，每个键都是一个字符串对象。

> 键空间的值就是数据库的值，每个值可以是字符串对象，列表对象，哈希对象，集合对象，有序集合对象中的任意一种。

数据库的键空间是一个字典，所以所有针对数据库的操作，都是通过对键空间字典进行操作来实现的。

**redis是一个单线程程序，它使用了IO多路复用模型(IO多路复用是指一个线程用来管理多个IO流，省去了线程进程切换的开销，IO多路复用搭配非阻塞IO使用，因为select返回可用不表示一定可用，如果使用阻塞IO，会导致线程阻塞)来处理IO事务，因此速度快**。

## redis事件

redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
> 文件事件(file event)：redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。

> 时间事件：一些定时操作。

### API

ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到IO多路复用程序的监听范围内，并对事件和事件处理器进行关联。

ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让IO多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。

ae.c/aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型。

ae.c/aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞等待套接字的给定类型事件产生，当事件成功产生或者等待超时之后，函数返回。

ae.c/aeApiPoll函数接受一个sys/time.hstruct timeval结构为参数，并在指定时间内，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当至少一个事件产生或者等待超时后，函数返回。

ae.c/aeProcessEvents函数是文件事件分配器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。

ae.c/aeGetApiName函数返回IO多路复用程序底层所使用的IO多路复用函数库的名称：返回epoll表示 底层为epoll函数库。

### 文件事件处理器

redis为文件事件编写了多个处理器，这些时间处理器分别用于实现不同的网络通信需求。

- 连接应答处理器

networking.c/acceptTcpHandler函数是redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。监听套接字产生AE_READABLE事件，就会引发应答处理器执行。

- 命令请求处理器

networking.c/readQueryFromClient函数是redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的请求命令，具体实现为unistd.h/read函数的包装。

- 命令回复处理器

networking.c/sendReplyToClient函数是redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。套接字产生AE_WRITEABLE事件时，就会引发命令回复处理器执行。

## redis集群

### 节点

一个redis集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，他们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。连接各个节点的工作可以使用cluster meet命令来完成：
```redis
cluster meet <ip> <port>
```
在集群模式下，节点会将用到的数据保存在cluster.h/clusterNode结构、cluster.h/clusterLink结构，以及cluster.h/clusterState结构中。

clusterNode结构保存一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等。

clusterLink结构保存了连接节点所需的相关信息，比如套接字描述符，输入输出缓冲区等。

clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态。里面有一个nodes字典保存节点的clusterNode结构，当前集群中所有节点的信息。

clusterState -> clusterNode -> clusterLink

### 槽指派

redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽中的其中一个，集群中的每个节点都可以处理0个或最多16384个槽。

当数据库中的16384个槽都有节点在处理时，集群处于上线状态；相反，只要有一个槽没有得到处理，那么集群处于下线状态。

通过向节点发送cluster addslots命令，可以将一个或多个槽指派给节点负责：
```redis
cluster addslots <slot> [slot...]

cluster addslots 0 1 2 3 4 ... 5000
```

- 使用两个数据结构来保存节点的槽指派信息：clusterState.slots数组记录了集群中所有槽的指派信息，是一个clusterNode指针，指向其指派的节点；clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，是一个char数组。

- 在集群中执行命令

当客户端向节点发送与数据库有关的命令时，接受命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：
> 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令；
> 否则节点会向客户端发送一个moved错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令。

- 计算键属于哪个槽

节点使用以下算法来计算给定键key属于哪个槽：
```python
def slot_number(key):
    return CRC16(key) & 16383
```
其中CRC16语句用于计算键key的CRC-16校验和，而&16383语句则用于计算出一个介于0至16383之间的整数作为键key的槽号。使用cluster keyslot <key>可以查看一个给定键属于哪个槽。

cluster keyslot命令就是通过调用上面给出的槽分配算法来实现的。

- 判断槽是否由当前节点负责处理

当节点计算出键所属的槽i之后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责：

(1) 如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端所发送的命令。

(2) 如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回moved错误，指引客户端转向正确的节点。

(3) 一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令。

(4) 集群节点保存键值对以及键值对过期时间的方式，与单机redis服务器保存键值对以及键值对过期的方式完全相同。节点与单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机redis服务器则没有这一限制。

### 重新分片

redis集群的重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。

### 复制与故障转移

redis集群中的节点可分为主节点和从节点，其中主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求。

**redis有四种模式：单机模式、主从复制模式、哨兵模式和集群模式(集群中的节点又可以分为主节点与从节点)。